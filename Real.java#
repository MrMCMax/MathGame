

import mathExceptions.ExDivisionPorCero;
public class Real
{
    protected boolean irracional;
    protected boolean transcendental;
    
    protected double numero;
    protected boolean negativo;
    protected boolean entero;

    public static final String[] conjuntos = { "R", "I", "Q", "Z", "N" };

    public Real() {
        numero = 0;
        irracional = false;
        negativo = false;
        entero = true;
        transcendental = false;
    }

    public Real(double n) {
        cambiarValor(n);
    }

    public void cambiarValor(double n) {
        numero = n;
        irracional = false;
        negativo = n < 0;
        entero = n % 1 == 0;
        transcendental = false;
    }

    public double getNumero() { return numero; }

    public String type() {
        int i = 0; //default
        if (irracional) {
            i = 1;
        } else {
            if (entero) {
                if (negativo) {
                    i = 3;
                } else {
                    i = 4;
                }
            } else {
                i = 2;
            }
        }
        return conjuntos[i];
    }

    /** Precondicion: type() == Q */
    public Fraccionario convertToQ() {
        Fraccionario q = fraccionGeneratriz(numero);
        return q;
    }

    /** Precondicion: type() == Z */
    public Entero convertToZ() {
        return new Entero((int)numero);
    }

    /** Precondicion: type() == N */
    public Natural convertToN() {
        Natural n = null;
        try {
            n = new Natural((int)numero);
        } catch (mathExceptions.ExcepcionNegativo ex) {
            n = null;
        }
        return n;
    }

    /**Precondición: esFraccionario == true */
    public static Fraccionario fraccionDecimalExacto(double d) {
        Fraccionario f;
        int potencia = (int)Math.pow(10, numeroDeFraccionarios(d));
        try {
            f = new Fraccionario((int)(d * potencia), potencia);
        } catch (ExDivisionPorCero ex) {
            return null;
        }
        return f;
    }
    
    /**Devuleve la fracción generatriz de un número decimal
     * @param d número decimal
     * @return Fracción generatriz (Fraccionario)
     */
    public static Fraccionario fraccionGeneratriz(double d) {
        Fraccionario f = null;
        int nDecimales = numeroDeFraccionarios(d);
        int[] periodo = null;
        if (nDecimales > 8) {
            periodo = hallarPeriodoMixto(d);
        }
        if (periodo == null) {
            return fraccionDecimalExacto(d);
        } else {
            /**Algoritmo para hallar la fracción generatriz. Funciona
             * tanto para periodos puros como mixtos.
             * Recordemos: 
             * periodoMixto[0] == periodo
             * periodoMixto[1] == nº cifras parte periodica
             * periodoMixto[2] == nº cifras parte no periodica
             */
            String cadena = Double.toString(d);
            int comaDecimal = cadena.indexOf(".");
            cadena = cadena.replace(".", "");
            String parteEntera = cadena.substring(0, comaDecimal);
            String parteNoPeriodica = cadena.substring(comaDecimal, 
                comaDecimal + periodo[2]);
            String partePeriodica = cadena.substring(comaDecimal + periodo[2],
                comaDecimal + periodo[2] + periodo[1]);
            String sustraendo = parteEntera + parteNoPeriodica + partePeriodica;
            String minuendo = parteEntera + parteNoPeriodica;
            String denominador = "0";
            for (int i = 0; i < periodo[1]; i++) {
                denominador += "9";
            }
            for (int i = 0; i < periodo[2]; i++) {
                denominador += "0";
            }
            try {
                int numerador = Integer.parseInt(sustraendo) - Integer.parseInt(minuendo);
                f = new Fraccionario(numerador, Integer.parseInt(denominador));
            } catch (ExDivisionPorCero ex) {
                System.out.println("Problemas con el denominador");
            }
            return f;
        }
    }
    
    /**
     * Devuelve un array de tres elementos: El primero
     * el periodo mixto, el segundo el nº de cifras del periodo,
     * y el tercero el nº de cifras de la parte no periódica.
     */
    public static int[] hallarPeriodoMixto(double d) {
        int inicio = 0;
        String strn = Double.toString(d);
        strn = strn.substring(strn.indexOf(".") + 1);
        int nFraccionarios = strn.length();
        int[] periodo = hallarPeriodoPuro(strn);
        while (inicio < nFraccionarios / 2 && periodo == null) {
            inicio++;
            periodo = hallarPeriodoPuro(strn.substring(inicio));
        }
        if (periodo == null) { return null; }
        else {
            return new int[] { periodo[0], periodo[1], inicio };
        }
    }

    /**Devuelve un array de dos elementos con un el
     * periodo puro de "d" en el primer elemento, y la
     * longitud del periodo el el segundo elemento.
     * Si d no tiene un periodo puro, devuelve null
     */
    public static int[] hallarPeriodoPuro(double d) {
        String strn = Double.toString(d);
        strn = strn.substring(strn.indexOf(".") + 1);
        return hallarPeriodoPuro(strn);
    }   //No se usa

    public static int[] hallarPeriodoPuro(String s) {
        int longitudPeriodo = 1;
        int digitosFraccionarios = s.length();
        int longitudPeriodicaPosible = digitosFraccionarios / 2;
        while(longitudPeriodo <= longitudPeriodicaPosible) {
            //Para evitar errores de redondeo, utilizaremos Strings
            String periodo = s.substring(0, longitudPeriodo);
            if (comprobarPeriodo(s, periodo)) {
                return new int[] { Integer.parseInt(periodo), longitudPeriodo };
            }
            longitudPeriodo++;
        }
        return null;
    }

    /**Comprueba si "n" es periódico puro de periodo "periodo".
     * @param n el número periódico
     * @param periodo el periodo a comprobar
     * @return boolean
     */
    public static boolean comprobarPeriodo(double n, int periodo) {
        String cifrasNumero = Double.toString(n);
        cifrasNumero = cifrasNumero.substring(cifrasNumero.indexOf(".") + 1);
        String cifrasPeriodo = Integer.toString(periodo);
        return comprobarPeriodo(cifrasNumero, cifrasPeriodo);
    }

    private static boolean comprobarPeriodo(String s, String periodo) {
        int digitosFraccionarios = s.length();
        int digitosPeriodicos = periodo.length();
        if (digitosFraccionarios / 2 < digitosPeriodicos) {
            return false;
        }
        int strIndex = 0;
        int periodoCount = 0;
        int nPeriodos = digitosFraccionarios / digitosPeriodicos;   //Deja sin comprobar el último periodo, que podría estar redondeado
        while(periodoCount < nPeriodos &&
        s.substring(strIndex, strIndex + digitosPeriodicos)
        .equals(periodo)) {
            periodoCount++;
            strIndex += digitosPeriodicos;
        }
        if (periodoCount == nPeriodos) {
            return true;
        } else {
            return false;
        }
    }

    public static int numeroDeFraccionarios(double n) {
        //Debido a errores de redondeo, utilizaremos strings para hallarlo
        Double d = new Double(n);
        String dec = d.toString();
        return dec.substring(dec.indexOf(".") + 1).length();
    }

    /** Precondicion: n >= 0 */
    public static int numeroDeDigitos(int n) {
        if (n / 10 == 0) {
            return 1;
        } else {
            return 1 + numeroDeDigitos(n / 10);
        }
    }
}
